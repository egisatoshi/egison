--
-- This file has been auto-generated by egison-translator.
--

toMathExpr arg := mathNormalize1 (toMathExpr' arg)

add' := cambda xs -> foldl b.+ (car xs) (cdr xs)

sub' := cambda xs -> foldl b.- (car xs) (cdr xs)

mul' := cambda xs -> foldl b.* (car xs) (cdr xs)

div' := b./

f.add' := cambda xs -> foldl f.+ (car xs) (cdr xs)

f.sub' := cambda xs -> foldl f.- (car xs) (cdr xs)

f.mul' := cambda xs -> foldl f.* (car xs) (cdr xs)

f.div' := f./

+ :=
  cambda xs ->
    if capply (||) (map float? xs)
      then capply f.add' (map (\x -> if float? x then x else itof x) xs)
      else mathNormalize1 capply add' xs

- :=
  cambda xs ->
    if capply (||) (map float? xs)
      then capply f.sub' (map (\x -> if float? x then x else itof x) xs)
      else mathNormalize1 capply sub' xs

* :=
  cambda xs ->
    if capply (||) (map float? xs)
      then capply f.mul' (map (\x -> if float? x then x else itof x) xs)
      else mathNormalize1 capply mul' xs

/ x y :=
  if float? x && float? y
    then f./ x y
    else if float? x
      then f./ x (itof y)
      else if float? y then f./ (itof x) y else b./ x y

reduceFraction := id

sum xs := if empty? xs then 0 else capply (+) xs

sum' xs := foldl add' 0 xs

product xs := if empty? xs then 1 else capply (*) xs

product' xs := foldl mul' 1 xs

power x n := mathNormalize1 (power' x n)

power' x n := foldl mul' 1 (take n (repeat1 x))

** x n :=
  if x = e
    then exp n
    else if rational? n
      then if n >= 0
        then if integer? n then power x n else `(^) x n
        else 1 / x ^ neg n
      else `(^) x n

power' x n :=
  if x = e
    then exp n
    else if rational? n
      then if n >= 0
        then if integer? n then power' x n else `(^) x n
        else div' 1 (power' x (neg n))
      else `(^) x n

gcd := cambda xs -> foldl b.gcd (car xs) (cdr xs)

gcd' := cambda xs -> foldl b.gcd' (car xs) (cdr xs)

b.gcd x y :=
  match (x, y) as (termExpr, termExpr) with
    | (_, #0) -> x
    | (#0, _) -> y
    | (term $a $xs, term $b $ys) ->
      mul'
        (b.gcd' (abs a) (abs b))
        (foldl mul' 1 (map 2#(power' %1 %2) (AC.intersect xs ys)))

b.gcd' x y :=
  match (x, y) as (integer, integer) with
    | (_, #0) -> x
    | (#0, _) -> y
    | (_, ?1#(%1 >= x)) -> b.gcd' (modulo y x) x
    | (_, _) -> b.gcd' y x

P./ fx gx x :=
  let as := reverse (coefficients fx x)
      bs := reverse (coefficients gx x)
      (zs, rs) := L./ as bs
   in ( sum' (map2 2#(mul' %1 (power' x %2)) (reverse zs) nats0)
      , sum' (map2 2#(mul' %1 (power' x %2)) (reverse rs) nats0) )
