--
-- This file has been auto-generated by egison-translator.
--

mathNormalize1 x :=
  if integer? x
    then x
    else let ret := capply compose (map 2#%1 (filter 2#(%2 x) rewriteRules1)) x
          in ret

rewriteRules1 :=
  [ (id, 1#True)
  , (rewriteRuleForI, 1#(containSymbol? i %1))
  , (rewriteRuleForWTerm, 1#(containSymbol? w %1))
  , (rewriteRuleForRtuTerm, 1#(containFunction? `rtu %1))
  , (rewriteRuleForPower, 1#(containFunction? `(^) %1))
  , (rewriteRuleForExp, 1#(containFunction? `exp %1))
  , (rewriteRuleForWPoly, 1#(containSymbol? w %1))
  , (rewriteRuleForRtuPoly, 1#(containFunction? `rtu %1))
  , (rewriteRuleForSqrt, 1#(containFunction? `sqrt %1))
  , (rewriteRuleForRt, 1#(containFunction? `rt %1))
  , (rewriteRuleForCosToSin, 1#(containFunctionWithOrder? `cos 2 %1))
  , (rewriteRuleForD/d, 1#True) ]

rewriteRuleForI := rewriteRuleForITerm

rewriteRuleForITerm := 1#(mapTerms rewriteRuleForITerm' %1)

rewriteRuleForITerm' term :=
  match term as mathExpr with
    | $a * #i ^ (?even? & $k) * $r -> mul' a (power' (-1) (quotient k 2)) r
    | $a * #i ^ $k * $r -> mul' a (power' (-1) (quotient k 2)) r i
    | _ -> term

rewriteRuleForW := 1#(compose rewriteRuleForWTerm rewriteRuleForWPoly %1)

rewriteRuleForWTerm := 1#(mapTerms rewriteRuleForWTerm' %1)

rewriteRuleForWPoly := 1#(mapPolys rewriteRuleForWPoly' %1)

rewriteRuleForWTerm' term :=
  match term as mathExpr with
    | $a * #w ^ (?1#(%1 >= 3) & $k) * $r -> mul' a r (power' w (k % 3))
    | _ -> term

rewriteRuleForWPoly' poly :=
  match poly as mathExpr with
    | $a * #w ^ #2 * $mr + $b * #w * #mr + $pr ->
      rewriteRuleForWPoly' (add' pr (mul' (-1) a mr) (mul' (b - a) mr w))
    | _ -> poly

rewriteRuleForRtu :=
  compose
    1#(mapTerms rewriteRuleForRtuTerm %1)
    1#(mapPolys rewriteRuleForRtuPoly %1)

rewriteRuleForRtuTerm := 1#(mapTerms rewriteRuleForRtuTerm' %1)

rewriteRuleForRtuPoly := 1#(mapPolys rewriteRuleForRtuPoly' %1)

rewriteRuleForRtuTerm' term :=
  match term as mathExpr with
    | $a * #`rtu $n ^ (?1#(%1 >= n) & $k) * $r ->
      mul' a (power' (rtu n) (k % n)) r
    | _ -> term

rewriteRuleForRtuPoly' poly :=
  match poly as mathExpr with
    | $a * #rtu $n ^ #1 * $mr + (loop $i (2, #(n - 1))
                                   (#a * #(rtu n) ^ #i * #mr + ...)
                                   $pr) ->
      rewriteRuleForRtuPoly' (add' pr (mul' (-1) a mr))
    | _ -> poly

rewriteRuleForSqrt := 1#(mapTerms rewriteRuleForSqrtTerm %1)

rewriteRuleForSqrtTerm term :=
  match term as mathExpr with
    | $a * #`sqrt $x * #`sqrt #x * $r -> rewriteRuleForSqrt (mul' a x r)
    | $a * #`sqrt (?term? & $x) * #`sqrt (?term? & $y) * $r ->
      let d := gcd x y
          (a1, x1) := fromMonomial (x / d)
          (a2, y1) := fromMonomial (y / d)
       in mul' a d (sqrt (mul' a1 a2)) (sqrt x1) (sqrt y1) r
    | _ -> term

rewriteRuleForRt := 1#(mapTerms rewriteRuleForRtTerm %1)

rewriteRuleForRtTerm term :=
  match term as mathExpr with
    | $a * #`rt $n $x ^ (?1#(%1 >= n) & $k) * $r ->
      mul' a (power' x (quotient k n)) (power' (rt n x) (k % n)) r
    | _ -> term

rewriteRuleForExp := 1#(mapTerms rewriteRuleForExpTerm %1)

rewriteRuleForExpTerm term :=
  match term as mathExpr with
    | $a * #`exp $x ^ (?1#(%1 >= 2) & $n) * $r ->
      rewriteRuleForExp (mul' a (exp (x * n)) r)
    | $a * #`exp $x * #`exp $y * $r ->
      rewriteRuleForExp (mul' a (exp (x + y)) r)
    | _ -> term

rewriteRuleForPower := 1#(mapTerms rewriteRuleForPowerTerm %1)

rewriteRuleForPowerTerm term :=
  match term as mathExpr with
    | $a * #`(^) #1 _ ^ _ * $r -> rewriteRuleForPower (mul' a r)
    | $a * #`(^) $x $y ^ (?1#(%1 >= 2) & $n) * $r ->
      rewriteRuleForPower (mul' a (x ^ (y * n)) r)
    | $a * #`(^) $x $y * #`(^) #x $z * $r ->
      rewriteRuleForPower (mul' a (x ^ (y + z)) r)
    | _ -> term

rewriteRuleForCosAndSin := 1#(mapPolys rewriteRuleForCosAndSinPoly %1)

rewriteRuleForCosAndSinExpr expr :=
  match (expr, expr) as (mathExpr, mathExpr) with
    | ( ($a * #`cos $x * $mr + $pr1) / $pr2
      , (_ * (#`cos #(x / 2) | #`sin #(x / 2)) * _ + _) / _ | _ / (_ * (#`cos
                                                                          #(x / 2) | #`sin
                                                                                       #(x / 2)) * _ + _) ) ->
      rewriteRuleForCosAndSinExpr
        (div'
           (add' (mul' a (sub' (cos (x / 2) ^ 2) (sin (x / 2) ^ 2)) mr) pr1)
           pr2)
    | ( ($a * #`sin $x * $mr + $pr1) / $pr2
      , (_ * (#`cos #(x / 2) | #`sin #(x / 2)) * _ + _) / _ | _ / (_ * (#`cos
                                                                          #(x / 2) | #`sin
                                                                                       #(x / 2)) * _ + _) ) ->
      rewriteRuleForCosAndSinExpr
        (div'
           (add' (mul' (mul' a 2) (mul' (cos (x / 2)) (sin (x / 2))) mr) pr1)
           pr2)
    | ( $pr2 / ($a * #`cos $x * $mr + $pr1)
      , (_ * (#`cos #(x / 2) | #`sin #(x / 2)) * _ + _) / _ | _ / (_ * (#`cos
                                                                          #(x / 2) | #`sin
                                                                                       #(x / 2)) * _ + _) ) ->
      rewriteRuleForCosAndSinExpr
        (div'
           pr2
           (add' (mul' a (sub' (cos (x / 2) ^ 2) (sin (x / 2) ^ 2)) mr) pr1))
    | ( $pr2 / ($a * #`sin $x * $mr + $pr1)
      , (_ * (#`cos #(x / 2) | #`sin #(x / 2)) * _ + _) / _ | _ / (_ * (#`cos
                                                                          #(x / 2) | #`sin
                                                                                       #(x / 2)) * _ + _) ) ->
      rewriteRuleForCosAndSinExpr
        (div'
           pr2
           (add' (mul' (mul' a 2) (mul' (cos (x / 2)) (sin (x / 2))) mr) pr1))
    | _ -> expr

rewriteRuleForCosAndSinPoly poly :=
  match poly as mathExpr with
    | $a * #`cos $x ^ #2 * $mr + #a * #`sin #x ^ #2 * #mr + $pr ->
      rewriteRuleForCosAndSinPoly (add' pr (mul' a mr))
    | $a * $mr + #(- a) * #`sin $x ^ #2 * #mr + $pr ->
      rewriteRuleForCosAndSinPoly (add' pr (mul' a (cos x ^ 2) mr))
    | $a * $mr + #(- a) * #`cos $x ^ #2 * #mr + $pr ->
      rewriteRuleForCosAndSinPoly (add' pr (mul' a (sin x ^ 2) mr))
    | _ -> poly

rewriteRuleForCosToSin := 1#(mapTerms rewriteRuleForCosToSinTerm' %1)

rewriteRuleForCosToSinTerm' term :=
  match term as mathExpr with
    | $a * #`cos $x ^ #2 * $mr ->
      mul' a (sub' 1 (sin x ^ 2)) (rewriteRuleForCosToSinTerm' mr)
    | _ -> term

rewriteRuleForD := 1#(mapTerms rewriteRuleForDTerm %1)

rewriteRuleForDTerm term :=
  match term as mathExpr with
    | _ * #d _ * #d _ * _ -> 0
    | _ -> term

rewriteRuleForD/d := 1#(mapPolys rewriteRuleForD/dPoly %1)

rewriteRuleForD/dPoly poly :=
  match poly as mathExpr with
    | $a * ($f & (func $g _ $arg $js)) ^ $n * $mr + $b * (func #g _ #arg ?1#(eq?/m
                                                                               (multiset
                                                                                  something)
                                                                               js
                                                                               %1)) ^ #n * #mr + $pr ->
      rewriteRuleForD/dPoly (add' (mul' (a + b) (f ^ n) mr) pr)
    | _ -> poly
